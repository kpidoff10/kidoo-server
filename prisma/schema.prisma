// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  output   = "../../kidoo-shared/prisma"
}

datasource db {
  provider = "postgresql"
}

enum TagType {
  MUSIC
  STORY
  SOUND
}

// Personnage TamaBotchi (admin)
enum CharacterSex {
  FEMALE
  MALE
}

enum CharacterPersonality {
  TIMID
  GRUMPY
  FUNNY
  ALWAYS_HUNGRY
  BASIC
}

model Character {
  id               String               @id @default(uuid())
  name             String?              // Display name (e.g. Gochi)
  defaultImageUrl  String?              // Default image (R2 or external URL)
  stylePrompt      String?              // Prompt style pour génération IA (émotions)
  characterContext String?              @db.Text // Description du personnage pour l'IA (ex: "fantôme sans bouche ni nez")
  sex              CharacterSex         // Female or male
  personality      CharacterPersonality // Default character / personality
  imageWidth       Int                  @default(280)  // Largeur image génération xAI (plein écran landscape)
  imageHeight      Int                  @default(240)  // Hauteur image génération xAI (plein écran landscape)
  createdAt        DateTime             @default(now())
  updatedAt        DateTime             @updatedAt

  clips            Clip[]
  emotionDevices   EmotionDevice[]
  rules            Rule[]

  @@map("characters")
}

// --- Émotions (roadmap) ---
enum EventType {
  RFID
  TEMP
  IMU
  TOUCH
  POWER
  SYSTEM
}

enum EventKey {
  TAG_PRESENT
  TAG_ABSENT
  TEMP_READING
  TEMP_HOT
  TEMP_COLD
  IMU_SHAKE
  IMU_TILT
  TOUCH_TAP
  TOUCH_LONG
  CHARGING_STARTED
  CHARGING_STOPPED
  SLEEP_ENTER
  SLEEP_EXIT
  CUSTOM
}

enum ClipStatus {
  DRAFT
  GENERATING
  READY
  FAILED
  DISABLED
}

enum FaceRegionKey {
  LEFT_EYE
  RIGHT_EYE
  MOUTH
}

enum CornerStyle {
  ROUNDED
  SQUARE
}

enum EmotionDeviceMode {
  NORMAL
  CHARGING
  SLEEP
}

model Emotion {
  id           String   @id @default(uuid())
  key          String   @unique // HOT, OK, COLD, BRUSH, SLEEP, etc.
  label        String   // Libellé affiché
  promptCustom String?  // Personnalisation du prompt (ex: "manger un poulet", "zzzz pour dormir")
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  clips            Clip[]
  deviceClipCaches DeviceClipCache[]
  emotionVideos    EmotionVideo[]

  @@map("emotions")
}

model Clip {
  id          String     @id @default(uuid())
  characterId String
  emotionId   String
  status      ClipStatus @default(DRAFT)
  fileUrl     String?    // URL .bin (R2)
  sha256      String?
  sizeBytes   Int?
  width       Int?      // 240
  height      Int?      // 280
  fps         Int?      // 10
  frames      Int?      // 60
  durationS      Float?    // 6
  prompt         String?   @db.Text
  variantPrompt  String?   @db.Text // Prompt personnalisé pour cette variante spécifique (ex: "ajouter des étoiles", "regard vers la gauche")
  modelName      String?   // grok-imagine-video
  xaiJobId       String?   // ID du job xAI (pour poll le résultat)
  previewUrl       String?   // MP4 base (vidéo xAI), jamais modifié
  workingPreviewUrl String?  // MP4 de travail (trim, etc.), utilisé pour display/édition
  loopStartFrame   Int?      // Frame (0-based) début de boucle
  loopEndFrame    Int?      // Frame (0-based) fin de boucle (si null = dernière frame)
  weight          Int       @default(100) // Poids pour sélection aléatoire
  tags           String[]  @default([])  // Tags libres (Postgres)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  character       Character         @relation(fields: [characterId], references: [id], onDelete: Cascade)
  emotion         Emotion           @relation(fields: [emotionId], references: [id], onDelete: Cascade)
  faceRegions     ClipFaceRegion[]
  artifacts       ClipArtifact[]
  deviceClipCaches DeviceClipCache[]
  emotionVideos   EmotionVideo[]    // Vidéos composées utilisant ce clip comme source

  @@index([characterId])
  @@index([emotionId])
  @@index([characterId, emotionId])
  @@index([status])
  @@map("clips")
}

model ClipArtifact {
  id          String       @id @default(uuid())
  clipId      String
  frameIndex  Int          @default(0)
  name        String       // Nom de l'artefact (ex: "zzz", "sleep")
  x           Float        // 0-1 normalisé
  y           Float
  w           Float
  h           Float
  cornerStyle CornerStyle  @default(ROUNDED)
  imageUrl    String?      // Image masque (fond noir + région blanche) hébergée sur R2
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  clip Clip @relation(fields: [clipId], references: [id], onDelete: Cascade)

  @@index([clipId])
  @@map("clip_artifacts")
}

model ClipFaceRegion {
  id          String       @id @default(uuid())
  clipId      String
  regionKey   FaceRegionKey  // LEFT_EYE | RIGHT_EYE | MOUTH
  frameIndex  Int            @default(0) // Index de frame (0-based)
  x           Float          // 0-1 normalisé
  y           Float
  w           Float
  h           Float
  cornerStyle CornerStyle    @default(ROUNDED) // Coins arrondis ou carrés (par région)
  imageUrl    String?        // Image masque (fond noir + région blanche) hébergée sur R2
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  clip Clip @relation(fields: [clipId], references: [id], onDelete: Cascade)

  @@unique([clipId, regionKey, frameIndex])
  @@index([clipId])
  @@map("clip_face_regions")
}

// Vidéo composée à partir de frames de clips existants (timeline custom)
model EmotionVideo {
  id          String     @id @default(uuid())
  emotionId   String
  sourceClipId String    // Clip source dont on utilise les frames
  name        String?    // Nom optionnel (ex: "Gochi dort v2")

  // Configuration vidéo
  fps         Int        @default(10)
  width       Int        @default(240)
  height      Int        @default(280)

  // Timelines de composition (3 phases: intro, loop, exit)
  introTimeline Json       // Array<TimelineFrame> - Phase d'introduction (optionnelle)
  loopTimeline  Json       // Array<TimelineFrame> - Phase de boucle (OBLIGATOIRE, min 1 frame)
  exitTimeline  Json       // Array<TimelineFrame> - Phase de sortie (optionnelle)

  // Résultat généré
  status      ClipStatus @default(DRAFT) // DRAFT, GENERATING, READY, FAILED
  binUrl      String?    // URL du .bin généré (R2)
  idxUrl      String?    // URL du .idx (index des frames pour ESP32)
  sha256      String?
  sizeBytes   Int?
  totalFrames Int?       // Nombre total de frames (somme des 3 timelines)
  durationS   Float?     // Durée calculée (max 6s)

  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  emotion     Emotion    @relation(fields: [emotionId], references: [id], onDelete: Cascade)
  sourceClip  Clip       @relation(fields: [sourceClipId], references: [id], onDelete: Cascade)

  @@unique([sourceClipId, emotionId])
  @@index([emotionId])
  @@index([sourceClipId])
  @@index([status])
  @@map("emotion_videos")
}

model EmotionDevice {
  id              String            @id @default(uuid())
  characterId     String
  pubnubChannel   String?
  mode            EmotionDeviceMode @default(NORMAL)
  isCharging      Boolean           @default(false)
  lastSeenAt      DateTime?
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  character       Character         @relation(fields: [characterId], references: [id], onDelete: Cascade)
  deviceClipCaches DeviceClipCache[]

  @@index([characterId])
  @@map("emotion_devices")
}

model DeviceClipCache {
  deviceId    String
  emotionId   String
  slot        Int      // 1..5
  clipId      String
  lastSeenAt  DateTime @default(now())
  lastPlayedAt DateTime?

  device  EmotionDevice @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  emotion Emotion       @relation(fields: [emotionId], references: [id], onDelete: Cascade)
  clip    Clip          @relation(fields: [clipId], references: [id], onDelete: Cascade)

  @@id([deviceId, emotionId, slot])
  @@index([deviceId])
  @@index([emotionId])
  @@index([clipId])
  @@map("device_clip_caches")
}

model Rule {
  id          String    @id @default(uuid())
  characterId String?   // null = règle globale
  enabled     Boolean   @default(true)
  priority    Int       @default(0) // Plus haut = prioritaire
  cooldownMs  Int       @default(0)
  eventType   EventType
  eventKey    EventKey
  conditions  Json?     // DSL conditions (MVP)
  response    Json      // { emotionKey, actions?, ... }
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  character Character? @relation(fields: [characterId], references: [id], onDelete: Cascade)

  @@index([characterId])
  @@index([enabled, eventType, eventKey])
  @@map("rules")
}

// RFID → objet → émotion (roadmap)
model ObjectType {
  id        String   @id @default(uuid())
  key       String   @unique // Ex: brush, bottle, etc.
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  rfidObjects RfidObject[]

  @@map("object_types")
}

model RfidObject {
  uid          String     @unique // UID du tag NFC
  objectTypeId String
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  objectType ObjectType @relation(fields: [objectTypeId], references: [id], onDelete: Cascade)

  @@index([objectTypeId])
  @@map("rfid_objects")
}

// Modèles Kidoo (aligné avec KIDOO_MODELS dans kidoo-shared)
enum KidooModel {
  basic
  dream
}

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  emailVerified DateTime?
  name          String?
  avatar        String?
  password      String? // Pour l'authentification par mot de passe
  isAdmin       Boolean   @default(false) // Accès admin (ex: upload firmware)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts      Account[]
  sessions      Session[]
  kidoos        Kidoo[]
  tags          Tag[]
  files File[]

  @@map("users")
}

model Kidoo {
  id                String     @id @default(uuid())
  name              String
  model             KidooModel @default(basic) // Modèle du Kidoo (basic, dream)
  macAddress        String?  // Adresse MAC WiFi (renvoyée par l'ESP32 lors du setup)
  bluetoothMacAddress String? // Adresse MAC Bluetooth (pour comparer lors des scans automatiques)
  deviceId          String   @unique // UUID du device BLE
  firmwareVersion   String?
  lastConnected     DateTime?
  isConnected       Boolean  @default(false)
  wifiSSID          String?  // Lecture seule, pour affichage uniquement (modification via Bluetooth uniquement)
  userId            String?
  isSynced          Boolean  @default(false)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  brightness        Int       @default(100) // Luminosité (10-100)
  sleepTimeout      Int       @default(30000) // Timeout de sommeil en ms (5000-300000)
  
  // Configuration du sleep mode (mode veille)
  sleepColorR       Int?      // Composante rouge de la couleur de veille (0-255, null si non configuré)
  sleepColorG       Int?      // Composante verte de la couleur de veille (0-255, null si non configuré)
  sleepColorB       Int?      // Composante bleue de la couleur de veille (0-255, null si non configuré)
  sleepEffect       Int?      // Effet LED pour le sleep mode (0 = LED_EFFECT_NONE, null si non configuré)

  user         User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  tags         Tag[]
  configBasic  KidooConfigBasic? // Configuration spécifique au modèle Basic (relation 1:1)
  configDream  KidooConfigDream? // Configuration spécifique au modèle Dream (relation 1:1)

  @@map("kidoos")
  @@index([userId])
  @@index([deviceId])
  @@index([model])
}

model Tag {
  id          String   @id @default(uuid()) // Clé primaire générée par Prisma
  tagId       String?  @unique // UUID généré par l'app et écrit sur le tag NFC (nullable temporairement pour migration)
  uid         String?  // UID du tag NFC (lecture seule, identifiant matériel du tag physique) - null jusqu'à la lecture du tag
  name        String?  // Nom optionnel pour le tag
  type        TagType? // Type du tag (enum: MUSIC, STORY, SOUND)
  kidooId     String
  userId      String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  kidoo       Kidoo    @relation(fields: [kidooId], references: [id], onDelete: Cascade)
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  multimediaFiles File[]

  @@map("tags")
  @@index([kidooId])
  @@index([userId])
  @@index([uid])
  @@index([tagId])
  @@index([type])
}

model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// Firmware par modèle Kidoo (Basic, Dream, etc.)
// partCount > 1 : firmware en parts (firmware/{model}/{version}/part0.bin, part1.bin, ...)
model Firmware {
  id        String     @id @default(uuid())
  model     KidooModel // Modèle cible (basic, dream)
  version   String   // Version (ex: 1.0.0)
  url       String   // URL publique du binaire (R2/S3) ou première part
  path      String   // Chemin dans le bucket (part0 ou fichier unique)
  fileName  String   // Nom du fichier (part0.bin ou firmware.bin)
  fileSize  Int      // Taille totale en octets
  partCount Int      @default(1) // Nombre de parts (1 = fichier unique)
  changelog String?  // Changelog en Markdown
  createdAt DateTime @default(now())

  @@unique([model, version])
  @@index([model])
  @@map("firmwares")
}

model File {
  id          String   @id @default(uuid())
  tagId       String   // ID du tag associé
  userId      String   // ID de l'utilisateur qui a uploadé le fichier
  url         String   // URL publique du fichier (Cloudflare R2)
  path        String   // Chemin dans le bucket (ex: kidooId/tagId/filename)
  fileName    String   // Nom du fichier
  originalName String  // Nom original du fichier uploadé
  size        Int      // Taille du fichier en octets
  mimeType    String   // Type MIME du fichier (ex: audio/mpeg)
  order       Int      @default(0) // Ordre d'affichage dans la liste (pour réorganisation)
  disabled    Boolean  @default(false) // Indique si le fichier est désactivé (en pause)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tag         Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("files")
  @@index([tagId])
  @@index([userId])
  @@index([createdAt])
  @@index([tagId, order]) // Index composite pour trier par tag et ordre
}

// Configuration spécifique au modèle Basic
// Note: Les configurations WiFi ne sont PAS stockées ici (restent sur le device, modifiables uniquement via Bluetooth)
// Note: sleepTransitionMs est géré nativement par l'ESP32, pas stocké en base
// Note: Les configurations LED (couleur et effet) ne sont PAS stockées ici (envoyées uniquement via Bluetooth en temps réel)
model KidooConfigBasic {
  id                String    @id @default(uuid())
  kidooId           String    @unique // Relation 1:1 avec Kidoo

  // Données de stockage (dernières valeurs reçues de l'ESP32)
  storageTotalBytes BigInt?   // Espace total en bytes (null si non disponible)
  storageFreeBytes  BigInt?   // Espace libre en bytes (null si non disponible)
  storageUsedBytes  BigInt?   // Espace utilisé en bytes (null si non disponible)
  storageFreePercent Int?     // Pourcentage d'espace libre (0-100, null si non disponible)
  storageUsedPercent Int?     // Pourcentage d'espace utilisé (0-100, null si non disponible)
  storageLastUpdated DateTime? // Date de dernière mise à jour des données de stockage
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  kidoo             Kidoo     @relation(fields: [kidooId], references: [id], onDelete: Cascade)

  @@map("kidoo_config_basic")
  @@index([kidooId])
}

// Configuration spécifique au modèle Dream
// Note: Les configurations WiFi ne sont PAS stockées ici (restent sur le device, modifiables uniquement via Bluetooth)
model KidooConfigDream {
  id                String    @id @default(uuid())
  kidooId           String    @unique // Relation 1:1 avec Kidoo

  // Configuration du rituel de sommeil (bedtime)
  // Couleur RGB (0-255)
  colorR            Int?      // Composante rouge de la couleur de coucher (0-255, null si non configuré)
  colorG            Int?      // Composante verte de la couleur de coucher (0-255, null si non configuré)
  colorB            Int?      // Composante bleue de la couleur de coucher (0-255, null si non configuré)
  
  // Luminosité
  brightness        Int?      // Luminosité des LEDs pour le coucher (0-255, null si non configuré)
  
  // Mode d'allumage
  allNight          Boolean   @default(false) // Si true, la veilleuse reste allumée toute la nuit, sinon elle s'éteint après une durée définie

  // Effet LED pour le coucher (null = couleur fixe, sinon nom de l'effet)
  effect            String?   // Effet LED: "none" (couleur fixe), "pulse", "rainbow-soft", "breathe", "nightlight", etc.

  // Configuration du réveil (wake-up)
  // Couleur RGB pour le réveil (0-255)
  wakeupColorR      Int?      // Composante rouge de la couleur de réveil (0-255, null si non configuré)
  wakeupColorG      Int?      // Composante verte de la couleur de réveil (0-255, null si non configuré)
  wakeupColorB      Int?      // Composante bleue de la couleur de réveil (0-255, null si non configuré)
  
  // Luminosité pour le réveil
  wakeupBrightness  Int?      // Luminosité des LEDs pour le réveil (0-255, null si non configuré)
  
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  kidoo             Kidoo     @relation(fields: [kidooId], references: [id], onDelete: Cascade)
  bedtimeSchedules  KidooConfigDreamBedtimeSchedule[]
  wakeupSchedules   KidooConfigDreamWakeupSchedule[]

  @@map("kidoo_config_dream")
  @@index([kidooId])
}

// Horaires de coucher par jour de la semaine pour le modèle Dream
model KidooConfigDreamBedtimeSchedule {
  id                  String    @id @default(uuid())
  kidooConfigDreamId  String    // Relation N:1 avec KidooConfigDream
  
  weekday             String    // Jour de la semaine: monday, tuesday, wednesday, thursday, friday, saturday, sunday
  hour                Int       // Heure de coucher (0-23)
  minute              Int       // Minute de coucher (0-59)
  activated           Boolean   @default(false) // Si true, le jour est activé pour l'heure de coucher
  
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  kidooConfigDream    KidooConfigDream @relation(fields: [kidooConfigDreamId], references: [id], onDelete: Cascade)

  @@unique([kidooConfigDreamId, weekday])
  @@index([kidooConfigDreamId])
  @@map("kidoo_config_dream_bedtime_schedule")
}

// Horaires de réveil par jour de la semaine pour le modèle Dream
model KidooConfigDreamWakeupSchedule {
  id                  String    @id @default(uuid())
  kidooConfigDreamId  String    // Relation N:1 avec KidooConfigDream
  
  weekday             String    // Jour de la semaine: monday, tuesday, wednesday, thursday, friday, saturday, sunday
  hour                Int       // Heure de réveil (0-23)
  minute              Int       // Minute de réveil (0-59)
  activated           Boolean   @default(false) // Si true, le jour est activé pour l'heure de réveil
  
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  kidooConfigDream    KidooConfigDream @relation(fields: [kidooConfigDreamId], references: [id], onDelete: Cascade)

  @@unique([kidooConfigDreamId, weekday])
  @@index([kidooConfigDreamId])
  @@map("kidoo_config_dream_wakeup_schedule")
}
